#lang racket

(require "utils.rkt")
(require racket/match)
;; Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are all figurate (polygonal) numbers and are generated by the following formulae:
;; Triangle 	  	P3,n=n(n+1)/2 	  	1, 3, 6, 10, 15, ...
;; Square 	  	P4,n=n2 	  	1, 4, 9, 16, 25, ...
;; Pentagonal 	  	P5,n=n(3n−1)/2 	  	1, 5, 12, 22, 35, ...
;; Hexagonal 	  	P6,n=n(2n−1) 	  	1, 6, 15, 28, 45, ...
;; Heptagonal 	  	P7,n=n(5n−3)/2 	  	1, 7, 18, 34, 55, ...
;; Octagonal 	  	P8,n=n(3n−2) 	  	1, 8, 21, 40, 65, ...

;; The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three interesting properties.

;;     The set is cyclic, in that the last two digits of each number is the first two digits of the next number (including the last number with the first).
;;     Each polygonal type: triangle (P3,127=8128), square (P4,91=8281), and pentagonal (P5,44=2882), is represented by a different number in the set.
;;     This is the only set of 4-digit numbers with this property.

;; Find the sum of the only ordered set of six cyclic 4-digit numbers for which each polygonal type: triangle, square, pentagonal, hexagonal, heptagonal, and octagonal, is represented by a different number in the set.

;; 6 cyclical, each from s = 3, 4, 5, 6, 7, 8

;; since they are cyclical we can start at s = 3 and see if we can continue to a different set

;; then a six cyclical 4 digit number can progress like this

;; abcd -> [cdab / cdba]
;; cdba -> [bacd / badc]

;; oh .... wow .... I misread the problem, the other two digits can be anything
;; my version attempts to solve the more difficult to analyze and impossible to complete
;; case in which the digits must be permutations of each other

;; ow well, the following is an analysis of swapping
;; and I thought a clever angle of attack


;; so it makes a tree, right means change order of changeable (the 2 on the right) digits

;;                 ((abcd))
;;         /                       \
;;     cdab                       (cdba)
;;    /    \                 /              \
;;*abcd  abdc             bacd             (badc)
;;       /  \            /    \            /       \
;;     dcab dcba     *cdba  cdab          (dcba)    dcab
;;    / \     \          /  \             /    \       / \
;;*abdc *abcd /\     *abcd  abdc      *badc   (bacd)abdc  abcd*
;;           /  \           / \               /     /  \
;;      *dcba dcab      dcab   dcba          /\  *dcab dcba
;;           /   \     /   \     /          /  \          \ 
;;      *abdc *abcd *abdc *abcd /\      *cdba (cdab)      /\
;;                             /  \           / \        /  \
;;                           *badc*bacd  ((abcd)) *abdc *badc*bacd    

;; so it needs to go; (original swap swap don't swap swap (don't->original)

;; let's try that out
;;     swap    swap    don't   swap   swap     don't
;; 1234 -> 3421 -> 2143 -> 4321 -> 2134 -> 3412 -> 1234

;; so a six-length four-digit-cycle is made by these operations alone

(define (less-than-10000 x) (< x 10000))
(define (less-than-1000 x) (< x 1000))

(define (build-nth-polygonal-number-list n)
  (dropf (takef (polygonal-n n 150) less-than-10000) less-than-1000))

;; A list of all the sets
(define triangular-numbers (build-nth-polygonal-number-list 3))
(define polygonal-number-sets (map list->set (map build-nth-polygonal-number-list (range 4 9))))

(define (front-back n) ;; when c is 0, a digit is lost
  (let ([answer (list->integer (match (integer->list n) [(list a b c d) (list c d a b)]))])
    (if (> answer 1000) answer 1111))) ; return garbage, that sounds like a good idea

(define (swap-front n) ;; use after swap, that is, in the rightmost function position
  (list->integer (match (integer->list n) [(list a b c d) (list a b d c)])))

(define (swap n)
  (swap-front (front-back n)))

(define (dont n)
  (front-back n))

(define operations-list (list swap swap dont swap swap))

;; now we can prove this works
;; (swap 1234) ; -> 3421
;; (swap 3421) ; -> 2143
;; (dont 2143)
;; (swap 4321)
;; (swap 2134)
;; (dont 3412) ; -> 1234 ;; and we already know about that number is triangular

;; (= 1234 (dont (swap (swap (dont (swap (swap 1234))))))) ; -> #t

(define (remove-n li n)
  (cond
    [(zero? n) (cdr li)] ;; trying to remove past index causes an error
    [else (cons (car li) (remove-n (cdr li) (sub1 n)))]))

(define (rotate-left li)
  (append (cdr li) (list (car li))))

;; keep in mind that we have to change the order to look across intersects
(define (find-set sets number ref)
  (cond
    [(null? sets) #f]
    [(set-member? (car sets) number) ref]
    [else (find-set (cdr sets) number (add1 ref))]))

(define (search triangular-numbers polygonal-number-sets operations)
  ;; so we take a triangular number and try to traverse all operations
  ;; we begin with the number in the accumulator
  (define (traverse polygonal-number-sets operations acc tries) ;; tries is how many times we rotated the sets
    ;; after applying an operation, can we find the new number in the sets?
    (if (null? operations) acc
        (let* ([new-number ((car operations) (car acc))]
               [new-acc (cons new-number acc)]
               [found-set (find-set polygonal-number-sets new-number 0)])
          (displayln acc)
          (cond
            ;; unless out of tries
            [(= tries (length polygonal-number-sets)) #f]
            [(not found-set) #f]
            ;; try using the that table
            [else (let ([answer (traverse (remove-n polygonal-number-sets found-set) (cdr operations) new-acc 0)])
                    (if answer answer
                        ;; try different table
                        (traverse (rotate-left polygonal-number-sets) operations acc (add1 tries))))]))))
  
  (let ([current-result (traverse polygonal-number-sets operations (list (car triangular-numbers)) 0)])
    (if current-result current-result
        (search (cdr triangular-numbers) polygonal-number-sets operations))))

;(search triangular-numbers polygonal-number-sets operations-list) ;; runs out of triangle numbers, no solution

;; second attempt

;; this should be much easier

;; despite the overhead, I'm treating numbers as numbers as much as possible
(define (first-two n)
  (list->integer (take (integer->list n) 2)))

(define (last-two n)
  (list->integer (drop (integer->list n) 2)))

(define sets (map list->seteq (map build-nth-polygonal-number-list (range 3 9))))


;; TODO write solution
(define (search sets)
  (define traverse sets 
